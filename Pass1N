import java.util.*;
import java.io.*;

public class Assembler {
    static List<Symbol> SYMTAB = new ArrayList<>();
    static List<Literal> LITTAB = new ArrayList<>();
    static Map<String, Opcode> OPTAB = new HashMap<>();
    static Map<String, Integer> REGTAB = new HashMap<>();
    static Map<String, Integer> CCTAB = new HashMap<>();
    static int LC = 0;

    static int searchSymbol(String label) {
        for (int i = 0; i < SYMTAB.size(); i++) {
            if (SYMTAB.get(i).label.equals(label))
                return i + 1; // 1-based index
        }
        return -1;
    }

    static int searchLiteral(String literal) {
        for (int i = 0; i < LITTAB.size(); i++) {
            Literal l = LITTAB.get(i);
            if (l.literal.equals(literal) && l.address == -1) {
                // Found an unassigned literal, return it
                return i + 1;
            }
        }
        // Not found or only found assigned literals, so return -1 to insert new
        return -1;
    }
    

    static boolean isLiteral(String str) {
        return str.startsWith("=");
    }

    static boolean isNumeric(String str) {
        try {
            Integer.parseInt(str);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    // Evaluate expression to address, e.g., LOOP+1
    static int evaluateExpression(String expr) {
        expr = expr.trim();
        if (isNumeric(expr)) return Integer.parseInt(expr);

        if (expr.contains("+") || expr.contains("-")) {
            char op = expr.contains("+") ? '+' : '-';
            String[] parts = expr.split("\\" + op, 2);
            String sym = parts[0].trim();
            String numStr = parts[1].trim();

            int symAddr = 0;
            int symIdx = searchSymbol(sym);
            if (symIdx != -1) symAddr = SYMTAB.get(symIdx - 1).address;

            int num = 0;
            try { num = Integer.parseInt(numStr); } catch (Exception e) {}

            return (op == '+') ? symAddr + num : symAddr - num;
        }
        // Just symbol
        int symIdx = searchSymbol(expr);
        if (symIdx != -1) return SYMTAB.get(symIdx - 1).address;

        return 0; // Undefined symbol fallback
    }

    // Print expression with symbols as (S,index)+offset
    static void printExpression(String expr) {
        expr = expr.trim();
        if (expr.contains("+") || expr.contains("-")) {
            char op = expr.contains("+") ? '+' : '-';
            String[] parts = expr.split("\\" + op, 2);
            String sym = parts[0].trim();
            String offset = parts[1].trim();
            int symIdx = searchSymbol(sym);
            if (symIdx != -1) {
                System.out.print("(S," + symIdx + ")" + op + offset);
            } else {
                System.out.print(expr);
            }
        } else {
            int symIdx = searchSymbol(expr);
            if (symIdx != -1) System.out.print("(S," + symIdx + ")");
            else if (isNumeric(expr)) System.out.print("(C," + expr + ")");
            else System.out.print(expr);
        }
    }

    // Parse and process each line
    static void parseLine(String line) {
        Scanner sc = new Scanner(line);
        if (!sc.hasNext()) return; // empty line

        String label = "", opcode = "", operand1 = "", operand2 = "";

        label = sc.next();

        if (OPTAB.containsKey(label)) { // no label, first word is opcode
            opcode = label;
            label = "";
        } else if (sc.hasNext()) {
            opcode = sc.next();
        } else {
            // line only label, nothing else
            return;
        }

        if (sc.hasNext()) operand1 = sc.next();
        if (sc.hasNext()) operand2 = sc.next();

        // Update SYMTAB for label
        if (!label.isEmpty()) {
            int idx = searchSymbol(label);
            if (idx == -1) {
                SYMTAB.add(new Symbol(label, LC));
            } else {
                SYMTAB.get(idx - 1).address = LC;
            }
        }

        if (!OPTAB.containsKey(opcode)) {
            System.err.println("Invalid opcode: " + opcode);
            return;
        }

        Opcode op = OPTAB.get(opcode);

        if (op.type.equals("AD")) { // Assembler Directives
            if (opcode.equals("START")) {
                LC = Integer.parseInt(operand1);
                System.out.printf("%3s (AD,%02d) (C,%s)%n", "", op.code, operand1);
            } 
            else if (opcode.equals("END")) {
                processLiterals();
                System.out.printf("%3s (AD,%02d) ", "", op.code);
                if (!operand1.isEmpty()) printExpression(operand1);
                System.out.println();
            } 
            else if (opcode.equals("ORIGIN")) {
                System.out.printf("    (AD,%02d) ", op.code);
                printExpression(operand1);
                System.out.println();

                // System.out.println("-------- NO IC --------");
                LC = evaluateExpression(operand1);
            } 
            else if (opcode.equals("EQU")) {
                // EQU no intermediate code
                //System.out.printf("    (AD,%02d) NO IC%n", op.code);
                System.out.println("-------- NO IC --------");

                int value = evaluateExpression(operand1);
                if (!label.isEmpty()) {
                    int idx = searchSymbol(label);
                    if (idx == -1) {
                        SYMTAB.add(new Symbol(label, value));
                    } else {
                        SYMTAB.get(idx - 1).address = value;
                    }
                }
            } 
            else if (opcode.equals("LTORG")) {
                System.out.println("-------- NO IC --------");
                processLiterals();
            }
        } 
        else if (op.type.equals("DL")) { // Declarative Statements
            System.out.printf("%3d (%s,%02d) ", LC, op.type, op.code);
            if (!operand1.isEmpty()) {
                if (isNumeric(operand1)) {
                    System.out.printf("(C,%s) ", operand1);
                } 
                else {
                    // If operand1 is symbol, print as symbol
                    int idx = searchSymbol(operand1);
                    if (idx != -1) System.out.printf("(S,%d) ", idx);
                    else System.out.print(operand1 + " ");
                }
            }
            System.out.println();
            // Increase LC by DS value or 1 for DC
            if (opcode.equals("DS")) {
                int size = 1;
                try { size = Integer.parseInt(operand1); } catch (Exception e) {}
                LC += size;
            } else if (opcode.equals("DC")) {
                LC += 1;
            }
        } 
        else if (op.type.equals("IS")) { // Imperative Statements
            System.out.printf("%3d (%s,%02d) ", LC, op.type, op.code);
            if (!operand1.isEmpty()) {
                if (REGTAB.containsKey(operand1)) {
                    System.out.printf("(R,%d) ", REGTAB.get(operand1));
                } 
                else if (CCTAB.containsKey(operand1)) {
                    System.out.printf("(CC,%d) ", CCTAB.get(operand1));
                } 
                else if (isLiteral(operand1)) {
                    int idx = searchLiteral(operand1);
                    if (idx == -1) {
                        LITTAB.add(new Literal(operand1, -1));
                        idx = LITTAB.size();
                    }
                    System.out.printf("(L,%d) ", idx);
                } 
                else if (isNumeric(operand1)) {
                    System.out.printf("(C,%s) ", operand1);
                } 
                else {
                    int idx = searchSymbol(operand1);
                    if (idx == -1) {
                        SYMTAB.add(new Symbol(operand1, -1));
                        idx = SYMTAB.size();
                    }
                    System.out.printf("(S,%d) ", idx);
                }
            }
            if (!operand2.isEmpty()) {
                if (REGTAB.containsKey(operand2)) {
                    System.out.printf("(R,%d) ", REGTAB.get(operand2));
                } 
                else if (CCTAB.containsKey(operand2)) {
                    System.out.printf("(CC,%d) ", CCTAB.get(operand2));
                } 
                else if (isLiteral(operand2)) {
                    int idx = searchLiteral(operand2);
                    if (idx == -1) {
                        LITTAB.add(new Literal(operand2, -1));
                        idx = LITTAB.size();
                    }
                    System.out.printf("(L,%d) ", idx);
                } 
                else if (isNumeric(operand2)) {
                    System.out.printf("(C,%s) ", operand2);
                } 
                else {
                    int idx = searchSymbol(operand2);
                    if (idx == -1) {
                        SYMTAB.add(new Symbol(operand2, -1));
                        idx = SYMTAB.size();
                    }
                    System.out.printf("(S,%d) ", idx);
                }
            }
            System.out.println();
            LC += 1;
        }
    }

    // Assign addresses to literals on LTORG or END and print DL lines for them
    static void processLiterals() {
        for (Literal l : LITTAB) {
            if (l.address == -1) {
                l.address = LC;

                // This printing is optional
                // System.out.printf("%3d (DL,01) (C,%s)%n", LC, l.literal.substring(1)); // DC literal value
                LC += 1;
            }
        }
    }

    public static void main(String[] args) {
        // Initialize OPTAB
        OPTAB.put("STOP", new Opcode("STOP", "IS", 0, 1));
        OPTAB.put("ADD", new Opcode("ADD", "IS", 1, 1));
        OPTAB.put("SUB", new Opcode("SUB", "IS", 2, 1));
        OPTAB.put("MULT", new Opcode("MULT", "IS", 3, 1));
        OPTAB.put("MOVER", new Opcode("MOVER", "IS", 4, 1));
        OPTAB.put("MOVEM", new Opcode("MOVEM", "IS", 5, 1));
        OPTAB.put("COMP", new Opcode("COMP", "IS", 6, 1));
        OPTAB.put("BC", new Opcode("BC", "IS", 7, 1));
        OPTAB.put("DIV", new Opcode("DIV", "IS", 8, 1));
        OPTAB.put("READ", new Opcode("READ", "IS", 9, 1));
        OPTAB.put("PRINT", new Opcode("PRINT", "IS", 10, 1));

        OPTAB.put("START", new Opcode("START", "AD", 1, 0));
        OPTAB.put("END", new Opcode("END", "AD", 2, 0));
        OPTAB.put("ORIGIN", new Opcode("ORIGIN", "AD", 3, 0));
        OPTAB.put("EQU", new Opcode("EQU", "AD", 4, 0));
        OPTAB.put("LTORG", new Opcode("LTORG", "AD", 5, 0));

        OPTAB.put("DC", new Opcode("DC", "DL", 1, 1));
        OPTAB.put("DS", new Opcode("DS", "DL", 2, 1));

        // REGTAB
        REGTAB.put("AREG", 1);
        REGTAB.put("BREG", 2);
        REGTAB.put("CREG", 3);
        REGTAB.put("DREG", 4);

        // CCTAB
        CCTAB.put("LT", 1);
        CCTAB.put("LE", 2);
        CCTAB.put("EQ", 3);
        CCTAB.put("GT", 4);
        CCTAB.put("GE", 5);
        CCTAB.put("ANY", 6);

        System.out.println("-------- Note: LC is not a part of IC; taken just for reference --------");

        try (BufferedReader br = new BufferedReader(new FileReader("input.asm"))) {
            String line;
            while ((line = br.readLine()) != null) {
                parseLine(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading input file");
        }

        // Print Symbol Table
        System.out.println("\nSYMBOL TABLE");
        System.out.println("Index\tSymbol\tAddress");
        for (int i = 0; i < SYMTAB.size(); i++) {
            Symbol s = SYMTAB.get(i);
            System.out.println((i + 1) + "\t" + s.label + "\t" + s.address);
        }

        // Print Literal Table
        System.out.println("\nLITERAL TABLE");
        System.out.println("Index\tLiteral\tAddress");
        for (int i = 0; i < LITTAB.size(); i++) {
            Literal l = LITTAB.get(i);
            System.out.println((i + 1) + "\t" + l.literal + "\t" + l.address);
        }
    }

    static class Symbol {
        String label;
        int address; // This is the LC

        Symbol(String label, int address) {
            this.label = label;
            this.address = address;
        }
    }

    static class Literal {
        String literal;
        int address; // This is the LC

        Literal(String literal, int address) {
            this.literal = literal;
            this.address = address;
        }
    }

    static class Opcode {
        String mnemonic;
        String type;
        int code;
        int length;

        Opcode(String mnemonic, String type, int code, int length) {
            this.mnemonic = mnemonic;
            this.type = type;
            this.code = code;
            this.length = length;
        }
    }
}
